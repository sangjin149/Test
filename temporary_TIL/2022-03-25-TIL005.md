# TIL-22/03/25

## :sparkles: 요약

## :star: 온라인 강의

### 1.그래프

#### 그래프의 특징

* 각 정점은 여러 개의 간선을 가질 수 있다.
* 간선의 방향성에 따라 방향/무방향그래프로 나눌 수 있다.
* 정점의 연결 상태에 따라 연결/비연결/완전 그래프로 나눌 수 있다.
* 간선은 가중치를 가질 수 있다.
* 사이클이 발생할 수 있다.
* 이차원 행렬로 정점 간의 간선 유무를 표현할 수 있다.
* 인접 행렬, 인접 리스트로 나타낼 수 있다.

### 2.트리

방향 그래프의 일종으로 정점을 가리키는 간선이 하나 밖에 없는 구조를 가지고 있다. 정점은 위치에 따라 루트 노드/노드/리프 노드로 나누어 부른다. 레벨(깊이)은 루트로부터 몇 개의 간선을 지나야 도달할 수 있는지 나타낸 것이다. 한 정점에서 뻗어나오는 간선의 수를 디그리(차수)라고 부른다.  

#### 트리의 특징

* 루트 노트를 제외한 모든 노드는 반드시 하나의 부모 노드를 가진다.
* 정점이 N개인 트리는 반드시 N-1개의 간선을 가진다.
* 루트에서 특정 정점으로 가는 경로는 유일하다.

#### 이진 트리

* 이진 트리는 "최악의 경우" 높이가 N이 될 수 있다.
* 노드가 M개인 포화/완전 이진 트리의 높이는 logN이다.
* 높이가 h인 포화 이진 트리는 2^h-1개의 노드를 가진다.
* 이진 트리는 혼자 쓰이기보다 다음 자료구조를 사용할 때 함께 쓰인다.: 이진 탐색 트리/힙/AVL트리/레드 블랙 트리
* 배열 혹은 요소에 링크가 2개 존재하는 연결 리스트로 구현 가능하다.

### 3.힙

힙: 이진 트리 형태를 가지며 우선순위가 높은 요소가 먼저 나가기 위해 요소가 삽입, 삭제될 때마다 이진트리를 나타내는 배열, 연결 리스트가 정렬된다.

#### 힙 원소 추가 알고리즘

1. 요소를 트리의 가장 말단 노드에 위치시킨다.
2. 추가 후 부모 노드보다 우선순위가 높다면 부모 노드와 순서를 바꾼다.
3. 위 과정을 반복하면 우선순위가 가장 높은 정점이 루트가 된다.
4. 완전 이진 트리의 높이는 logN이기 때문에 힙의 요소 추가 알고리즘은 O(log N)시간복잡도를 가진다.

#### 힙 원소 제거 알고리즘

1. 요소 제거는 루트 노드만 가능하다.
2. 루트 노드가 제거된 후 가장 마지막 노드가 루트 노드로 옮겨진다.
3. 루트 노드의 두 자식 노드 중 우선순위가 높은 노드와 바꾼다.
4. 두 자식 노드가 우선순위가 더 낮을 때까지 반복한다.

#### 힙의 특징

* 우선순위가 높은 요소가 먼저 나간다
* 루트가 가장 큰 값이 되는 최대 힙과 루트가 가장 작은 값이 되는 최소 힙이 있다.

### 4.트라이

트라이: 문자열을 저장하고 효율적으로 탐색하기 위한 구조의 트리 구조

### 5.정렬 알고리즘

#### 비교 정렬

* 버블 정렬(n2): 인접한 두 요소를 검사하여 정렬하는 알고리즘
* 선택 정렬(n2): 선택한 요소와 가장 우선순위가 높은 요소를 교환하는 정렬 알고리즘
* 삽입 정렬(n2): 선택한 요소를 삽입할 수 있는 위치를 찾아 삽입하는 방식의 정렬 알고리즘

#### 분산식 정렬

* 분할 정복이란?: 정리 대상을 2묶음식 계속 나눈 다음 처리한 후 합치는 전략
* 합병정렬(nlogn): 모두 나눈 후 각각의 묶음에 대해 비교를 모두 실행함
* 퀵 정렬(nlogn): 하나의 피봇을 정해 피봇과 비교하여 피봇의 양방향으로 분류한 다음, 양방향의 묶음에서 다시 피봇을 정하고...재귀적으로 정렬하는 방법

### 6.이진 탐색

이진 탐색: 정렬되어있는 요소들을 반씩 제외하며 찾는 알고리즘

#### 이진 탐색의 특징

* 반드시 정렬되어있어야 사용할 수 가 있다.
* 배열 혹은 이진 트리를 이용하여 구현할 수 있다. 이진 트리를 사용할 경우 이진 트리의 특수한 형태인 이진 탐색 트리를 사용한다.
* O(log n) 시간복잡도인만큼 상당히 빠르다.

#### 이진 탐색 트리의 문제점

* 최악의 경우 한쪽으로 편향된 트리가 될 수 있다.
* 그런 경우 순차 탐색과 동일한 시간복잡도를 가진다.
* 이를 해결하기 위해 다음 자료구조를 이용할 수 있다: AVL트리, 레드-블랙 트리

## :star2: 느낀 점 & 추가로 공부할 것

* Array.prototype.map(func())의 인자에 들어가는 함수의 첫 매개변수는 각 원소, 두번째는 원소의 인덱스, 세번째는 map을 호출한 배열이다. 반환값은 func에 각 원소를 넣은 반환값의 배열이다.
* Object와 Map 비교
  
  1. Object와 달리 Map은 모든 값을 가질 수 있다.
  2. Map은 크기가 자동으로 추적된다
  3. Map은 삽입된 순서대로 반복된다.
  
* A가 없다면 B를 해라 Object.A /*undefined*/ || B
* ...나열 가능한 객체: 배열이 개별 원소가 된다.
* Object.entries: for in 순서에 따라 [key, value] 쌍의 배열을 반환한다.
* flatMap(): map과 비슷하지만 반환받는 배열의 원소 중 배열이 있으면 배열을 모두 해제한다.

지금까지 공부한 자료구조/알고리즘

* 선형자료구조: 배열, 연결 리스트, 스택, 큐, 해시 테이블
* 비선형 자료구조: 그래프, 트리, 이진 트리(힙, 이진 탐색 트리), 트라이
* 비교 정렬: 버블 정렬, 선택 정렬, 삽입 정렬
* 분산 정렬: 합병 정렬, 퀵 정렬
* 이진 탐색: 정렬되어있는 요소들을 반씩 제외하며 찾는 알고리즘

오늘과 주말동안 할 일:

  1. 베스트앨범(해시테이블 사용): 실습&문제풀이
  2. 가장 먼 노드(그래프): 실습&문제풀이
  3. 가장 큰 수(정렬): 실습
  4. 입국심사(이진 탐색): 실습
  5. 힘, 이진 탐색 트리 공부
  6. 전위순회/중위순회/후위순회 구현(트리): 과제 (힌트: 스택, 재귀 호출)
  7. 자동 완성 기능 코드 (이전에 트리 파트에 사용된 레벨 순회를 응용하여 구현하시오!)
