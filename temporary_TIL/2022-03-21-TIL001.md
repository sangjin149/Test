# TIL-22/03/21

## :sparkles: 요약

  오늘은 리아 매니점의 오픈 미팅에서 앞으로의 일과에 대한 간략한 소개와 임시 팀을 배정받았다. 오늘의 온라인 강의에서는 프론트엔드 개발자의 역량에 대한 간략한 소개와 JS 문법에 대한 간략한 학습을 했다. 이전에 공부했던 것을 참고해 TIL 내용을 보강했다.

## :star: 온라인 강의

### 1.변수의 선언

변수는 var/let/const를 통해 선언할 수 있다. 변수는 선언, 초기화, 할당의 과정을 거쳐서 사용할 수 있는데 자바스크립트의 경우 모든 변수의 선언부만이 _함수의 최상단_으로 끌어올려진다(Hoisted). 이때 var과 let의 차이점이 발생하는데 var의 경우 undefined로 초기화 되고, let의 경우 어떤 값도 할당되지 않는다. 결국 let으로 사용된 변수를 사용하기 위해서는 초기화된 문장을 실행해야만 하는 것이다.
한편 함수의 최상단으로 끌어올려진다는 특성 때문에 재밌는 일이 생기기도 한다.

```javascript
var scope = "global";
f();
function f() {
    // var scope; 이 호이스팅되어 지역변수 scipe이 전역변수 scope을 가린다. 
    console.log(scope);  //undefined(지역변수 scope은 초기화되지 않았으므로)
    var scope = "local"; //사실상 scope = "local"이다.
    console.log(scope); //local
}
console.log(scope); //global
```

한편 var의 이런 특성이 직관성을 매우 떨어트리기 때문에 ECMAScript6 부터는 let 키워드를 도입해 변수를 선언하는 것을 권장한다. let 또한 선언부가 호이스팅되지만 undefined가 할당되지 않아 사실상 스코프 유효범위 규칙을 사용하는 것과 마찬가지이기 때문에 직관성과 안정성이 뛰어나기 때문이다.

### 2.메모리의 사용

JS의 변수에 저장될 수 있는 값은 크게 원시 타입/객체 타입으로 나눌 수 있다.

    원시 타입: 불리언, null, undefined, 숫자(Infinity/NAN), _문자열_
    객체 타입: 그 외 모두 

원시 타입의 경우 콜스택 영역에 저장되며, 만일 기존에 같은 값을 저장한 변수가 있다면 따로 공간을 할당받지 않고 해당 공간을 사용한다. 객체 타입의 경우 힙 영역에 저장된다. JS는 가비지 콜렉터가 마크&스윕 알고리즘을 통해 더이상 호출되는 것이 불가능한 저장공간을 자동으로 해제하기 때문에 따로 메모리의 할당과 해제에 신경을 쓸 필요는 없다.

### 3.표현식과 연산자

표현식은 JS가 값으로 평가하는 식이다.

JS의 몇몇 연산자에는 중요한 특징이 있다. 

* &&과 || : JS에서 이 둘은 단축평가가 적용되기 때문에 앞의 표현식의 값 때문에 뒤의 표현식의 값이 무의미해질 경우(&&의 경우 앞이 False, ||의 경우 앞이 True)이면 뒤의 표현식을 실행하지 않는다.
* in: "name" in obj 로 쓰이며 obj 안에 해당 이름을 가진 프로퍼티가 있는지 반환한다.
 배열에 쓰일 때는 해당 인덱스에 원소가 있는지 반환한다.
* instanceof: (name) instanceof (classname) 으로 쓰이며 해당 class에 속한 인스턴스인지 반환한다.
* typeof: 값의 자료형을 반환한다.
* delete: 지정된 객체의 지정된 프로퍼티를 제거한다.
* == 와 === : ===는 두 피연산자의 타입이 다르면 False, 같은 타입이면 같은 값을 가지면 True를 반환한다. ==는 보다 얕은 비교로, 둘의 타입이 다르면 toString(), valueOf() 메소드를 통해 같은 타입으로 만든 뒤 비교한다. 이때, 원시값의 경우 메소드를 가질 수 없기 때문에 래퍼 객체를 사용하여 연산한다. 

### 4.객체와 배열

JS에서 객체란, 열쇠값에 대응하는 값을 저장한 묶음({ }으로 표현)이다. 객체는 3가지 방식으로 선언 및 초기화할 수 있다.

1. 객체 리터럴: { } 을 통해 명시한 객체를 할당. 한번 쓰고 버리는 객체를 사용할 때 객체 리터럴을 쓰기도 한다. 
2. 생성자 함수: new prototypename() 과 같은 생성자 함수로 만들어진 객체는 생성자 함수의 프로토타입이 생성된 객체의 프로토타입이 된다. 
3. Object.create(prototype, property_addon): 첫인자를 프로토타입으로, 두번째 인자를 프로퍼티로 가지고있는 객체를 반환한다.
   
```javascript
let sample = { prop_name1: prop_value, prop_name2: prop_value}; 
var o = new Object(); //Object.prototype 
```

객체의 열쇠값, 값 묶음을 프로퍼티라 부른다. 프로퍼티는 크게 두가지 방식으로 접근할 수 있다. 

```javascript
objectname.propname;
objectname["propname"];
```

배열은 특히 정수로 된 키값을 사용하여 값에 빠르게 접근하도록 설계된 객체이다. 배열의 핵심은 정수로 된 이름을 가진 프로퍼티&length 프로퍼티이다. Array 클래스가 아니더라도 두 특성을 지닌 객체는 유사배열 객체로서 대부분의 배열 관련 메소드가 잘 동작한다. JS는 원소의 타입이 고정적이지 않다는 점에서 특기할만하다.

#### 여러 가지 유용한 배열 메소드

``` javascript
a = ["zero, "one"];

//스택처럼 작동
a.push("zero"); //작동: 배열의 맨 끝에 zero 원소를 추가한다. 반환: 바뀐 length 값
a.push("one", "two");
a.pop(); //작동: length값 1감소 반환: 삭제된 값
//큐처럼 작동
a.shift(); //작동: 맨 앞의 값을 삭제하고 모든 인덱스값을 1씩 감소시킨다 반환: 삭제된 값
a.unshift("zero"); //작동: 맨 앞에 0을 추가+기존의 원소들은 인덱스 값이 하나씩 커진다. 반환: length 값
delete a[2]; //프로퍼티처럼 인덱스에 할당된 원소도 지울 수 있다. 해당 공백을 다른 원소가 대신하지 않기 때문에 희소배열이 된다. 

 a = [1,2,3,4,5];

//a.join();
a.join(); // '1,2,3,4,5' 반환
//a.reverse(); 배열을 뒤집는다.
a.reverse(); // a는 [5,4,3,2,1]이 된다. 
//a.sort(); 오름차순으로 정리
a.sort(function(a, b) {/*함수 내용*/ return num;})
// 배열의 모든 원소에 대하여 function을 적용하여 num>0 이면 a와 b의 자리를 바꿈
//a.concat()
a.concat([6,7],[8,9]); // [1,2,4,5,6,7,8,9] 반환
//a.slice(); a를 수정하지 않고 새 배열 반환
a.slice(2,4); // [3,4,5] 반환
//a.splice(); a를 직접 수정
a.splice(2); // a는 [1,2]로 수정, 함수는 잘라낸 부분인 [3,4,5] 반환
a.splice(2,1); // a는 [1,2,5]로 수정, 함수는 잘라낸 부분인 [3,4] 반환
a.splice(2,1,'a','b');
// 첫번째 인자는 스타트 끊는 인덱스, 두번째 인자는 그뒤로 몇개의 원소를 들어낼지 결정, 세번째부터는 삽입할 원소
```

### 4.클로저

 -함수는 "함수가 정의된 시점"의 변수 유효범위를 사용하여 함수가 실행된다.
 -이때, 함수 객체와 함수의 변수가 해석되는 유효범위를 아울러 클로저라고 부른다.
 -예를 들어 아래와 같은 상황에서는, f.scope가 정의될 때 유효범위체인에는 f(), checkscope()과 그들의 변수가 같이 저장되어있는데, 이때의 scope 값은 checkscope의 지역변수 checkscope.scope를 따라가므로 "local scope"이 출력된다.
 -클로저의 이와 같은 성질을 통해 다른 언어의 private과 같은 접근 제한을 함수의 프로퍼티에 걸 수 있다.

``` javascript
var scope = "global scope"
function checkscope() {    //함수 안의 함수!!
 var scope = "local scope"
 function f() { return scope; }
 return f;
}
checkscope()(); // checkscope()=>f, checkscope()()=>f.scope 
```
